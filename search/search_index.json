{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pygdbmi - Get Structured Output from GDB's Machine Interface Documentation https://cs01.github.io/pygdbmi Source Code https://github.com/cs01/pygdbmi Python ( py ) gdb machine interface ( mi ) GDB/MI is a line based machine oriented text interface to GDB and is activated by specifying using the --interpreter command line option (see Mode Options). It is specifically intended to support the development of systems which use the debugger as just one small component of a larger system. What's in the box? A function to parse gdb machine interface string output and return structured data types (Python dicts) that are JSON serializable. Useful for writing the backend to a gdb frontend. For example, gdbgui uses pygdbmi on the backend. A Python class to control and interact with gdb as a subprocess To get machine interface output from gdb, run gdb with the --interpreter=mi2 flag like so: gdb --interpreter=mi2 Installation pip install pygdbmi Compatibility Operating Systems Cross platform support for Linux, macOS and Windows Linux/Unix Ubuntu 14.04 and 16.04 have been tested to work. Other versions likely work as well. macOS Note: the error please check gdb is codesigned - see taskgated(8) can be fixed by codesigning gdb with these instructions . If the error is not fixed, please create an issue in github . Windows Windows 10 has been tested to work with MinGW and cygwin. gdb versions gdb 7.6+ has been tested. Older versions may work as well. Examples gdb mi defines a syntax for its output that is suitable for machine readability and scripting: example output : -> - break - insert main <- ^ done , bkpt = { number = \"1\" , type = \"breakpoint\" , disp = \"keep\" , enabled = \"y\" , addr = \"0x08048564\" , func = \"main\" , file = \"myprog.c\" , fullname = \"/home/myprog.c\" , line = \"68\" , thread - groups = [ \"i1\" ], times = \"0\" } <- ( gdb ) Use pygdbmi.gdbmiparser.parse_response to turn that string output into a JSON serializable dictionary from pygdbmi import gdbmiparser from pprint import pprint response = gdbmiparser . parse_response ( '^done,bkpt={number=\"1\",type=\"breakpoint\",disp=\"keep\", enabled=\"y\",addr=\"0x08048564\",func=\"main\",file=\"myprog.c\",fullname=\"/home/myprog.c\",line=\"68\",thread-groups=[\"i1\"],times=\"0\"' ) pprint ( response ) pprint ( response ) # Prints: # {'message': 'done', # 'payload': {'bkpt': {'addr': '0x08048564', # 'disp': 'keep', # 'enabled': 'y', # 'file': 'myprog.c', # 'fullname': '/home/myprog.c', # 'func': 'main', # 'line': '68', # 'number': '1', # 'thread-groups': ['i1'], # 'times': '0', # 'type': 'breakpoint'}}, # 'token': None, # 'type': 'result'} Programmatic Control Over gdb But how do you get the gdb output into Python in the first place? If you want, pygdbmi also has a class to control gdb as subprocess. You can write commands, and get structured output back: from pygdbmi.gdbcontroller import GdbController from pprint import pprint # Start gdb process gdbmi = GdbController () print ( gdbmi . command ) # print actual command run as subprocess # Load binary a.out and get structured response response = gdbmi . write ( '-file-exec-file a.out' ) pprint ( response ) # Prints: # [{'message': 'thread-group-added', # 'payload': {'id': 'i1'}, # 'stream': 'stdout', # 'token': None, # 'type': 'notify'}, # {'message': 'done', # 'payload': None, # 'stream': 'stdout', # 'token': None, # 'type': 'result'}] Now do whatever you want with gdb. All gdb commands, as well as gdb machine interface commands are acceptable. gdb mi commands give better structured output that is machine readable, rather than gdb console output. mi commands begin with a - . response = gdbmi . write ( '-break-insert main' ) # machine interface (MI) commands start with a '-' response = gdbmi . write ( 'break main' ) # normal gdb commands work too, but the return value is slightly different response = gdbmi . write ( '-exec-run' ) response = gdbmi . write ( 'run' ) response = gdbmi . write ( '-exec-next' , timeout_sec = 0.1 ) # the wait time can be modified from the default of 1 second response = gdbmi . write ( 'next' ) response = gdbmi . write ( 'next' , raise_error_on_timeout = False ) response = gdbmi . write ( 'next' , raise_error_on_timeout = True , timeout_sec = 0.01 ) response = gdbmi . write ( '-exec-continue' ) response = gdbmi . send_signal_to_gdb ( 'SIGKILL' ) # name of signal is okay response = gdbmi . send_signal_to_gdb ( 2 ) # value of signal is okay too response = gdbmi . interrupt_gdb () # sends SIGINT to gdb response = gdbmi . write ( 'continue' ) response = gdbmi . exit () Parsed Output Format Each parsed gdb response consists of a list of dictionaries. Each dictionary has keys message , payload , token , and type . message contains a textual message from gdb, which is not always present. When missing, this is None . payload contains the content of gdb's output, which can contain any of the following: dictionary , list , string . This too is not always present, and can be None depending on the response. token If an input command was prefixed with a (optional) token then the corresponding output for that command will also be prefixed by that same token. This field is only present for pygdbmi output types nofity and result . When missing, this is None . The type is defined based on gdb's various mi output record types , and can be result - the result of a gdb command, such as done , running , error , etc. notify - additional async changes that have occurred, such as breakpoint modified console - textual responses to cli commands log - debugging messages from gdb's internals output - output from target target - output from remote target done - when gdb has finished its output Contributing Documentation fixes, bug fixes, performance improvements, and functional improvements are welcome. You may want to create an issue before beginning work to make sure I am interested in merging it to the master branch. pygdbmi uses nox for automation. See available tasks with nox -l Run tests and lint with nox -s tests nox -s lint Positional arguments passed to nox -s tests are passed directly to pytest . For instance, to run only the parse tests use nox -s tests -- tests/test_gdbmiparser.py See pytest 's documentation for more details on how to run tests. To format code using the correct settings use nox -s format Or, to format only specified files, use nox -s format -- example.py pygdbmi/IoManager.py Making a release Only maintainers of the pygdbmi package on PyPi can make a release. In the following steps, replace these strings with the correct values: <REMOTE> is the name of the remote for the main pygdbmi repository (for instance, origin ) <VERSION> is the version number chosen in step 2. To make a release: Checkout the master branch and pull from the main repository with git pull <REMOTE> master Decide the version number for the new release; we follow Semantic Versioning but prefixing the version with 0. : given a version number 0.SECOND.THIRD.FOURTH , increment the: SECOND component when you make incompatible API changes THIRD component when you add functionality in a backwards compatible manner FOURTH component when you make backwards compatible bug fixes Update CHANGELOG.md to list the chosen version number instead of ## dev Update __version__ in pygdbmi/__init__.py to the chosen version number Create a branch, for instance using git checkout -b before-release-<VERSION> Commit your changes, for instance using git commit -a -m 'Bump version to <VERSION> for release' Check that the docs look fine by serving them locally with nox -s serve_docs Push the branch, for instance with git push --set-upstream <REMOTE> before-release-<VERSION> If tests pass on the PR you created, you can merge into master Go to the new release page and prepare the release: Add a tag in the form v<VERSION> (for example v0.1.2.3 ) Set the title to pygdbmi v<VERSION> (for example pygdbmi v0.1.2.3 ) Copy and paste the section for the new release only from CHANGELOG.md excluding the line with the version number Press \u201cPublish release\u201d Publish the release to PyPI with nox -s publish Publish the docs with nox -s publish_docs Verify that the PyPi page for pygdbmi looks correct Verify that the published docs look correct Prepare for changes for the next release by adding something like this above the previous entries in CHANGELOG.md (where <VERSION+1> is <VERSION> with the last digit increaded by 1): ``` .dev0 Replace this line with new entries ``` Create a branch for the changes with git checkout -b after-release-<VERSION> Commit the change with git commit -m 'Prepare for work on the next release' CHANGELOG.md Push the branch with git push --set-upstream <REMOTE> after-release-<VERSION> If tests pass, merge into master Similar projects tsgdbmi A port of pygdbmi to TypeScript danielzfranklin/gdbmi A port of pygdbmi to Rust Projects Using pygdbmi gdbgui implements a browser-based frontend to gdb, using pygdbmi on the backend PINCE is a gdb frontend that aims to provide a reverse engineering tool and a reusable library focused on games. It uses pygdbmi to parse gdb/mi based output for some functions avatar\u00b2 is an orchestration framework for reversing and analysing firmware of embedded devices. It utilizes pygdbmi for internal communication to different analysis targets. UDB is a proprietary time-travel debugger for C and C++ based on GDB. It uses pygdbmi in its extensive test suite to parse the debugger's output. pwndbg-gui is a user-friendly graphical interface for pwndbg , a tool that simplifies exploit development and reverse engineering with GDB. It uses pygdbmi to interact with GDB and get structured responses. Know of another project? Create a PR and add it here. Authors Chad Smith (main author and creator). Marco Barisione (co-maintainer). The community . Thanks especially to @mariusmue, @bobthekingofegypt, @mouuff, and @felipesere.","title":"Home"},{"location":"#whats-in-the-box","text":"A function to parse gdb machine interface string output and return structured data types (Python dicts) that are JSON serializable. Useful for writing the backend to a gdb frontend. For example, gdbgui uses pygdbmi on the backend. A Python class to control and interact with gdb as a subprocess To get machine interface output from gdb, run gdb with the --interpreter=mi2 flag like so: gdb --interpreter=mi2","title":"What's in the box?"},{"location":"#installation","text":"pip install pygdbmi","title":"Installation"},{"location":"#compatibility","text":"","title":"Compatibility"},{"location":"#operating-systems","text":"Cross platform support for Linux, macOS and Windows Linux/Unix Ubuntu 14.04 and 16.04 have been tested to work. Other versions likely work as well. macOS Note: the error please check gdb is codesigned - see taskgated(8) can be fixed by codesigning gdb with these instructions . If the error is not fixed, please create an issue in github . Windows Windows 10 has been tested to work with MinGW and cygwin.","title":"Operating Systems"},{"location":"#gdb-versions","text":"gdb 7.6+ has been tested. Older versions may work as well.","title":"gdb versions"},{"location":"#examples","text":"gdb mi defines a syntax for its output that is suitable for machine readability and scripting: example output : -> - break - insert main <- ^ done , bkpt = { number = \"1\" , type = \"breakpoint\" , disp = \"keep\" , enabled = \"y\" , addr = \"0x08048564\" , func = \"main\" , file = \"myprog.c\" , fullname = \"/home/myprog.c\" , line = \"68\" , thread - groups = [ \"i1\" ], times = \"0\" } <- ( gdb ) Use pygdbmi.gdbmiparser.parse_response to turn that string output into a JSON serializable dictionary from pygdbmi import gdbmiparser from pprint import pprint response = gdbmiparser . parse_response ( '^done,bkpt={number=\"1\",type=\"breakpoint\",disp=\"keep\", enabled=\"y\",addr=\"0x08048564\",func=\"main\",file=\"myprog.c\",fullname=\"/home/myprog.c\",line=\"68\",thread-groups=[\"i1\"],times=\"0\"' ) pprint ( response ) pprint ( response ) # Prints: # {'message': 'done', # 'payload': {'bkpt': {'addr': '0x08048564', # 'disp': 'keep', # 'enabled': 'y', # 'file': 'myprog.c', # 'fullname': '/home/myprog.c', # 'func': 'main', # 'line': '68', # 'number': '1', # 'thread-groups': ['i1'], # 'times': '0', # 'type': 'breakpoint'}}, # 'token': None, # 'type': 'result'}","title":"Examples"},{"location":"#programmatic-control-over-gdb","text":"But how do you get the gdb output into Python in the first place? If you want, pygdbmi also has a class to control gdb as subprocess. You can write commands, and get structured output back: from pygdbmi.gdbcontroller import GdbController from pprint import pprint # Start gdb process gdbmi = GdbController () print ( gdbmi . command ) # print actual command run as subprocess # Load binary a.out and get structured response response = gdbmi . write ( '-file-exec-file a.out' ) pprint ( response ) # Prints: # [{'message': 'thread-group-added', # 'payload': {'id': 'i1'}, # 'stream': 'stdout', # 'token': None, # 'type': 'notify'}, # {'message': 'done', # 'payload': None, # 'stream': 'stdout', # 'token': None, # 'type': 'result'}] Now do whatever you want with gdb. All gdb commands, as well as gdb machine interface commands are acceptable. gdb mi commands give better structured output that is machine readable, rather than gdb console output. mi commands begin with a - . response = gdbmi . write ( '-break-insert main' ) # machine interface (MI) commands start with a '-' response = gdbmi . write ( 'break main' ) # normal gdb commands work too, but the return value is slightly different response = gdbmi . write ( '-exec-run' ) response = gdbmi . write ( 'run' ) response = gdbmi . write ( '-exec-next' , timeout_sec = 0.1 ) # the wait time can be modified from the default of 1 second response = gdbmi . write ( 'next' ) response = gdbmi . write ( 'next' , raise_error_on_timeout = False ) response = gdbmi . write ( 'next' , raise_error_on_timeout = True , timeout_sec = 0.01 ) response = gdbmi . write ( '-exec-continue' ) response = gdbmi . send_signal_to_gdb ( 'SIGKILL' ) # name of signal is okay response = gdbmi . send_signal_to_gdb ( 2 ) # value of signal is okay too response = gdbmi . interrupt_gdb () # sends SIGINT to gdb response = gdbmi . write ( 'continue' ) response = gdbmi . exit ()","title":"Programmatic Control Over gdb"},{"location":"#parsed-output-format","text":"Each parsed gdb response consists of a list of dictionaries. Each dictionary has keys message , payload , token , and type . message contains a textual message from gdb, which is not always present. When missing, this is None . payload contains the content of gdb's output, which can contain any of the following: dictionary , list , string . This too is not always present, and can be None depending on the response. token If an input command was prefixed with a (optional) token then the corresponding output for that command will also be prefixed by that same token. This field is only present for pygdbmi output types nofity and result . When missing, this is None . The type is defined based on gdb's various mi output record types , and can be result - the result of a gdb command, such as done , running , error , etc. notify - additional async changes that have occurred, such as breakpoint modified console - textual responses to cli commands log - debugging messages from gdb's internals output - output from target target - output from remote target done - when gdb has finished its output","title":"Parsed Output Format"},{"location":"#contributing","text":"Documentation fixes, bug fixes, performance improvements, and functional improvements are welcome. You may want to create an issue before beginning work to make sure I am interested in merging it to the master branch. pygdbmi uses nox for automation. See available tasks with nox -l Run tests and lint with nox -s tests nox -s lint Positional arguments passed to nox -s tests are passed directly to pytest . For instance, to run only the parse tests use nox -s tests -- tests/test_gdbmiparser.py See pytest 's documentation for more details on how to run tests. To format code using the correct settings use nox -s format Or, to format only specified files, use nox -s format -- example.py pygdbmi/IoManager.py","title":"Contributing"},{"location":"#making-a-release","text":"Only maintainers of the pygdbmi package on PyPi can make a release. In the following steps, replace these strings with the correct values: <REMOTE> is the name of the remote for the main pygdbmi repository (for instance, origin ) <VERSION> is the version number chosen in step 2. To make a release: Checkout the master branch and pull from the main repository with git pull <REMOTE> master Decide the version number for the new release; we follow Semantic Versioning but prefixing the version with 0. : given a version number 0.SECOND.THIRD.FOURTH , increment the: SECOND component when you make incompatible API changes THIRD component when you add functionality in a backwards compatible manner FOURTH component when you make backwards compatible bug fixes Update CHANGELOG.md to list the chosen version number instead of ## dev Update __version__ in pygdbmi/__init__.py to the chosen version number Create a branch, for instance using git checkout -b before-release-<VERSION> Commit your changes, for instance using git commit -a -m 'Bump version to <VERSION> for release' Check that the docs look fine by serving them locally with nox -s serve_docs Push the branch, for instance with git push --set-upstream <REMOTE> before-release-<VERSION> If tests pass on the PR you created, you can merge into master Go to the new release page and prepare the release: Add a tag in the form v<VERSION> (for example v0.1.2.3 ) Set the title to pygdbmi v<VERSION> (for example pygdbmi v0.1.2.3 ) Copy and paste the section for the new release only from CHANGELOG.md excluding the line with the version number Press \u201cPublish release\u201d Publish the release to PyPI with nox -s publish Publish the docs with nox -s publish_docs Verify that the PyPi page for pygdbmi looks correct Verify that the published docs look correct Prepare for changes for the next release by adding something like this above the previous entries in CHANGELOG.md (where <VERSION+1> is <VERSION> with the last digit increaded by 1): ```","title":"Making a release"},{"location":"#dev0","text":"Replace this line with new entries ``` Create a branch for the changes with git checkout -b after-release-<VERSION> Commit the change with git commit -m 'Prepare for work on the next release' CHANGELOG.md Push the branch with git push --set-upstream <REMOTE> after-release-<VERSION> If tests pass, merge into master","title":".dev0"},{"location":"#similar-projects","text":"tsgdbmi A port of pygdbmi to TypeScript danielzfranklin/gdbmi A port of pygdbmi to Rust","title":"Similar projects"},{"location":"#projects-using-pygdbmi","text":"gdbgui implements a browser-based frontend to gdb, using pygdbmi on the backend PINCE is a gdb frontend that aims to provide a reverse engineering tool and a reusable library focused on games. It uses pygdbmi to parse gdb/mi based output for some functions avatar\u00b2 is an orchestration framework for reversing and analysing firmware of embedded devices. It utilizes pygdbmi for internal communication to different analysis targets. UDB is a proprietary time-travel debugger for C and C++ based on GDB. It uses pygdbmi in its extensive test suite to parse the debugger's output. pwndbg-gui is a user-friendly graphical interface for pwndbg , a tool that simplifies exploit development and reverse engineering with GDB. It uses pygdbmi to interact with GDB and get structured responses. Know of another project? Create a PR and add it here.","title":"Projects Using pygdbmi"},{"location":"#authors","text":"Chad Smith (main author and creator). Marco Barisione (co-maintainer). The community . Thanks especially to @mariusmue, @bobthekingofegypt, @mouuff, and @felipesere.","title":"Authors"},{"location":"CHANGELOG/","text":"pygdbmi release history 0.12.0.0 Added a flag return_on_result , which causes an immediate return when a response of type 'result' is received, instead of waiting until the timeout passes. 0.11.0.0 Breaking changes Removed pygdbmi.IoManager.make_non_blocking from the public API; it's unrelated and was not meant to be public Other changes Fixed a bug where notifications without a payload were not recognized as such Invalid octal sequences produced by GDB are left unchanged instead of causing a UnicodeDecodeError (#64) Fix a crash on Windows by waiting for the GDB process to exit in GdbController.exit Added type annotations to the whole public API Updated the examples in README.md to use the current API and show the results printed by this version of pygdbmi (#69) Internal changes Update and freeze dependencies for documentation generation Refactored the code to parse MI records to decrease the number of regex matches to perform Added __all__ to all modules, which means that star imports (like from pygdbmi.gdbmiparser import * ) will not pollute the namespace with modules used by pygdbmi itself Added nox -s format to re-format the source code using the correct options Reformatted all imports with isort , and use it as part of nox -s lint and nox -s format Converted tests to use pytest's test structure rather than the unittest-based one Added mypy configuration to detect more problems and to force all code to be annotated Added a test for example.py Replaced uses of distutils.spawn.find_executable , which is deprecated, with shutil.which Ran pyupgrade (with option --py37-plus ) on the codebase to convert to Python 3.7 idioms Excluded some common backup and cache files from MANIFEST.in to prevent unwanted files to be included which causes check-manifest to fail Fix .flake8 to not cause errors with some versions of the flake8 tool 0.10.0.2 Strings containing escapes are now unescaped, both for messages in error records, which were previously mangled (#57), and textual records, which were previously left escaped (#58) Dropped support for Python 3.6 and added explicit support for Python 3.9 and 3.10. 0.10.0.1 Fix bug with time_to_check_for_additional_output_sec , as it was not being used when passed to GdbController 0.10.0.0 Breaking Changes Drop support for Python 3.5 Update GdbController() API. New API is GdbController(command: Optional[List[str]], time_to_check_for_additional_output_sec: Optional[int]) . GdbController.verify_valid_gdb_subprocess() was removed Remove NoGdbProcessError error Other Changes Add new IoManager class to handle more generic use-cases [dev] use pytest for testing gdb mi parsing remains unchanged 0.9.0.3 Drop support for 2.7, 3.4 Add support for 3.7, 3.8 Add py.typed file so mypy can enforce type hints on pygdbmi Do not log in StringStream (#36) Updates to build and CI tests (use nox) Use mkdocs and mkdocstrings Doc updates 0.9.0.2 More doc updates 0.9.0.1 Update docs 0.9.0.0 Stop buffering output Use logger in GdbController; modify verbose arguments. Remove support for Python 3.3 0.8.4.0 Add method get_subprocess_cmd to view the gdb command run in the shell 0.8.3.0 Improve reading gdb responses on unix (performance, bugfix) (@mouuff) 0.8.2.0 Add support for record and replay (rr) gdb supplement 0.8.1.1 Discard unexpected text from gdb 0.8.1.0 Add native Windows support 0.8.0.0 Make parsing more efficient when gdb outputs large strings Add new methods to GdbController class: spawn_new_gdb_subprocess , send_signal_to_gdb , and interrupt_gdb 0.7.4.5 Update setup.py 0.7.4.4 Fix windows ctypes import (#23, @rudolfwalter) 0.7.4.3 Workaround gdb bug with repeated dictionary keys 0.7.4.2 Improved buffering of incomplete gdb mi output (@trapito) Remove support of Python 3.2 0.7.4.1 Preserve leading and trailing spaces in gdb/mi output (plus unit tests) Add unit test for buffering of gdb/mi output Documentation updates Refactoring 0.7.4.0 Add more exception types ( NoGdbProcessError , GdbTimeoutError ) Add logic fixes for Windows (@johncf) Use codecs.open() to open the readme.rst, to prevent locale related bugs (@mariusmue) 0.7.3.3 Add alternate pipe implementation for Windows 0.7.3.2 Replace epoll with select for osx compatibility (@felipesere) 0.7.3.1 Fix README 0.7.3.0 Add support for gdb/mi (optional) tokens (@mariusmue)","title":"Changelog"},{"location":"CHANGELOG/#pygdbmi-release-history","text":"","title":"pygdbmi release history"},{"location":"CHANGELOG/#01200","text":"Added a flag return_on_result , which causes an immediate return when a response of type 'result' is received, instead of waiting until the timeout passes.","title":"0.12.0.0"},{"location":"CHANGELOG/#01100","text":"Breaking changes Removed pygdbmi.IoManager.make_non_blocking from the public API; it's unrelated and was not meant to be public Other changes Fixed a bug where notifications without a payload were not recognized as such Invalid octal sequences produced by GDB are left unchanged instead of causing a UnicodeDecodeError (#64) Fix a crash on Windows by waiting for the GDB process to exit in GdbController.exit Added type annotations to the whole public API Updated the examples in README.md to use the current API and show the results printed by this version of pygdbmi (#69) Internal changes Update and freeze dependencies for documentation generation Refactored the code to parse MI records to decrease the number of regex matches to perform Added __all__ to all modules, which means that star imports (like from pygdbmi.gdbmiparser import * ) will not pollute the namespace with modules used by pygdbmi itself Added nox -s format to re-format the source code using the correct options Reformatted all imports with isort , and use it as part of nox -s lint and nox -s format Converted tests to use pytest's test structure rather than the unittest-based one Added mypy configuration to detect more problems and to force all code to be annotated Added a test for example.py Replaced uses of distutils.spawn.find_executable , which is deprecated, with shutil.which Ran pyupgrade (with option --py37-plus ) on the codebase to convert to Python 3.7 idioms Excluded some common backup and cache files from MANIFEST.in to prevent unwanted files to be included which causes check-manifest to fail Fix .flake8 to not cause errors with some versions of the flake8 tool","title":"0.11.0.0"},{"location":"CHANGELOG/#01002","text":"Strings containing escapes are now unescaped, both for messages in error records, which were previously mangled (#57), and textual records, which were previously left escaped (#58) Dropped support for Python 3.6 and added explicit support for Python 3.9 and 3.10.","title":"0.10.0.2"},{"location":"CHANGELOG/#01001","text":"Fix bug with time_to_check_for_additional_output_sec , as it was not being used when passed to GdbController","title":"0.10.0.1"},{"location":"CHANGELOG/#01000","text":"Breaking Changes Drop support for Python 3.5 Update GdbController() API. New API is GdbController(command: Optional[List[str]], time_to_check_for_additional_output_sec: Optional[int]) . GdbController.verify_valid_gdb_subprocess() was removed Remove NoGdbProcessError error Other Changes Add new IoManager class to handle more generic use-cases [dev] use pytest for testing gdb mi parsing remains unchanged","title":"0.10.0.0"},{"location":"CHANGELOG/#0903","text":"Drop support for 2.7, 3.4 Add support for 3.7, 3.8 Add py.typed file so mypy can enforce type hints on pygdbmi Do not log in StringStream (#36) Updates to build and CI tests (use nox) Use mkdocs and mkdocstrings Doc updates","title":"0.9.0.3"},{"location":"CHANGELOG/#0902","text":"More doc updates","title":"0.9.0.2"},{"location":"CHANGELOG/#0901","text":"Update docs","title":"0.9.0.1"},{"location":"CHANGELOG/#0900","text":"Stop buffering output Use logger in GdbController; modify verbose arguments. Remove support for Python 3.3","title":"0.9.0.0"},{"location":"CHANGELOG/#0840","text":"Add method get_subprocess_cmd to view the gdb command run in the shell","title":"0.8.4.0"},{"location":"CHANGELOG/#0830","text":"Improve reading gdb responses on unix (performance, bugfix) (@mouuff)","title":"0.8.3.0"},{"location":"CHANGELOG/#0820","text":"Add support for record and replay (rr) gdb supplement","title":"0.8.2.0"},{"location":"CHANGELOG/#0811","text":"Discard unexpected text from gdb","title":"0.8.1.1"},{"location":"CHANGELOG/#0810","text":"Add native Windows support","title":"0.8.1.0"},{"location":"CHANGELOG/#0800","text":"Make parsing more efficient when gdb outputs large strings Add new methods to GdbController class: spawn_new_gdb_subprocess , send_signal_to_gdb , and interrupt_gdb","title":"0.8.0.0"},{"location":"CHANGELOG/#0745","text":"Update setup.py","title":"0.7.4.5"},{"location":"CHANGELOG/#0744","text":"Fix windows ctypes import (#23, @rudolfwalter)","title":"0.7.4.4"},{"location":"CHANGELOG/#0743","text":"Workaround gdb bug with repeated dictionary keys","title":"0.7.4.3"},{"location":"CHANGELOG/#0742","text":"Improved buffering of incomplete gdb mi output (@trapito) Remove support of Python 3.2","title":"0.7.4.2"},{"location":"CHANGELOG/#0741","text":"Preserve leading and trailing spaces in gdb/mi output (plus unit tests) Add unit test for buffering of gdb/mi output Documentation updates Refactoring","title":"0.7.4.1"},{"location":"CHANGELOG/#0740","text":"Add more exception types ( NoGdbProcessError , GdbTimeoutError ) Add logic fixes for Windows (@johncf) Use codecs.open() to open the readme.rst, to prevent locale related bugs (@mariusmue)","title":"0.7.4.0"},{"location":"CHANGELOG/#0733","text":"Add alternate pipe implementation for Windows","title":"0.7.3.3"},{"location":"CHANGELOG/#0732","text":"Replace epoll with select for osx compatibility (@felipesere)","title":"0.7.3.2"},{"location":"CHANGELOG/#0731","text":"Fix README","title":"0.7.3.1"},{"location":"CHANGELOG/#0730","text":"Add support for gdb/mi (optional) tokens (@mariusmue)","title":"0.7.3.0"},{"location":"api/gdbcontroller/","text":"This module defines the GdbController class which runs gdb as a subprocess and can write to it and read from it to get structured output. GdbController Source code in pygdbmi/gdbcontroller.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class GdbController : def __init__ ( self , command : Optional [ List [ str ]] = None , time_to_check_for_additional_output_sec : float = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ) -> None : \"\"\" Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Args: command: Command to run in shell to spawn new gdb subprocess time_to_check_for_additional_output_sec: When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. Returns: New GdbController object \"\"\" if command is None : command = DEFAULT_GDB_LAUNCH_COMMAND if not any ([( \"--interpreter=mi\" in c ) for c in command ]): logger . warning ( \"Adding `--interpreter=mi3` (or similar) is recommended to get structured output. \" + \"See https://sourceware.org/gdb/onlinedocs/gdb/Mode-Options.html#Mode-Options.\" ) self . abs_gdb_path = None # abs path to gdb executable self . command : List [ str ] = command self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . gdb_process : Optional [ subprocess . Popen ] = None self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) gdb_path = command [ 0 ] if not gdb_path : raise ValueError ( \"a valid path to gdb must be specified\" ) else : abs_gdb_path = shutil . which ( gdb_path ) if abs_gdb_path is None : raise ValueError ( 'gdb executable could not be resolved from \" %s \"' % gdb_path ) else : self . abs_gdb_path = abs_gdb_path self . spawn_new_gdb_subprocess () def spawn_new_gdb_subprocess ( self ) -> int : \"\"\"Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id \"\"\" if self . gdb_process : logger . debug ( \"Killing current gdb subprocess (pid %d )\" % self . gdb_process . pid ) self . exit () logger . debug ( f 'Launching gdb: { \" \" . join ( self . command ) } ' ) # Use pipes to the standard streams self . gdb_process = subprocess . Popen ( self . command , shell = False , stdout = subprocess . PIPE , stdin = subprocess . PIPE , stderr = subprocess . PIPE , bufsize = 0 , ) assert self . gdb_process . stdin is not None assert self . gdb_process . stdout is not None self . io_manager = IoManager ( self . gdb_process . stdin , self . gdb_process . stdout , self . gdb_process . stderr , self . time_to_check_for_additional_output_sec , ) return self . gdb_process . pid def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , ) -> List [ Dict ]: \"\"\"Get gdb response. See IoManager.get_gdb_response() for details\"\"\" return self . io_manager . get_gdb_response ( timeout_sec , raise_error_on_timeout , return_on_result ) def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , read_response : bool = True , ) -> List [ Dict ]: \"\"\"Write command to gdb. See IoManager.write() for details\"\"\" return self . io_manager . write ( mi_cmd_to_write , timeout_sec , raise_error_on_timeout , return_on_result , read_response , ) def exit ( self ) -> None : \"\"\"Terminate gdb process\"\"\" if self . gdb_process : self . gdb_process . terminate () self . gdb_process . wait () self . gdb_process . communicate () self . gdb_process = None return None __init__ ( command = None , time_to_check_for_additional_output_sec = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC ) Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Parameters: Name Type Description Default command Optional [ List [ str ]] Command to run in shell to spawn new gdb subprocess None time_to_check_for_additional_output_sec float When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC Returns: Type Description None New GdbController object Source code in pygdbmi/gdbcontroller.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def __init__ ( self , command : Optional [ List [ str ]] = None , time_to_check_for_additional_output_sec : float = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ) -> None : \"\"\" Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Args: command: Command to run in shell to spawn new gdb subprocess time_to_check_for_additional_output_sec: When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. Returns: New GdbController object \"\"\" if command is None : command = DEFAULT_GDB_LAUNCH_COMMAND if not any ([( \"--interpreter=mi\" in c ) for c in command ]): logger . warning ( \"Adding `--interpreter=mi3` (or similar) is recommended to get structured output. \" + \"See https://sourceware.org/gdb/onlinedocs/gdb/Mode-Options.html#Mode-Options.\" ) self . abs_gdb_path = None # abs path to gdb executable self . command : List [ str ] = command self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . gdb_process : Optional [ subprocess . Popen ] = None self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) gdb_path = command [ 0 ] if not gdb_path : raise ValueError ( \"a valid path to gdb must be specified\" ) else : abs_gdb_path = shutil . which ( gdb_path ) if abs_gdb_path is None : raise ValueError ( 'gdb executable could not be resolved from \" %s \"' % gdb_path ) else : self . abs_gdb_path = abs_gdb_path self . spawn_new_gdb_subprocess () exit () Terminate gdb process Source code in pygdbmi/gdbcontroller.py 137 138 139 140 141 142 143 144 def exit ( self ) -> None : \"\"\"Terminate gdb process\"\"\" if self . gdb_process : self . gdb_process . terminate () self . gdb_process . wait () self . gdb_process . communicate () self . gdb_process = None return None get_gdb_response ( timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True , return_on_result = False ) Get gdb response. See IoManager.get_gdb_response() for details Source code in pygdbmi/gdbcontroller.py 109 110 111 112 113 114 115 116 117 118 def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , ) -> List [ Dict ]: \"\"\"Get gdb response. See IoManager.get_gdb_response() for details\"\"\" return self . io_manager . get_gdb_response ( timeout_sec , raise_error_on_timeout , return_on_result ) spawn_new_gdb_subprocess () Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id Source code in pygdbmi/gdbcontroller.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def spawn_new_gdb_subprocess ( self ) -> int : \"\"\"Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id \"\"\" if self . gdb_process : logger . debug ( \"Killing current gdb subprocess (pid %d )\" % self . gdb_process . pid ) self . exit () logger . debug ( f 'Launching gdb: { \" \" . join ( self . command ) } ' ) # Use pipes to the standard streams self . gdb_process = subprocess . Popen ( self . command , shell = False , stdout = subprocess . PIPE , stdin = subprocess . PIPE , stderr = subprocess . PIPE , bufsize = 0 , ) assert self . gdb_process . stdin is not None assert self . gdb_process . stdout is not None self . io_manager = IoManager ( self . gdb_process . stdin , self . gdb_process . stdout , self . gdb_process . stderr , self . time_to_check_for_additional_output_sec , ) return self . gdb_process . pid write ( mi_cmd_to_write , timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True , return_on_result = False , read_response = True ) Write command to gdb. See IoManager.write() for details Source code in pygdbmi/gdbcontroller.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , read_response : bool = True , ) -> List [ Dict ]: \"\"\"Write command to gdb. See IoManager.write() for details\"\"\" return self . io_manager . write ( mi_cmd_to_write , timeout_sec , raise_error_on_timeout , return_on_result , read_response , )","title":"gdbcontroller"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController","text":"Source code in pygdbmi/gdbcontroller.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class GdbController : def __init__ ( self , command : Optional [ List [ str ]] = None , time_to_check_for_additional_output_sec : float = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ) -> None : \"\"\" Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Args: command: Command to run in shell to spawn new gdb subprocess time_to_check_for_additional_output_sec: When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. Returns: New GdbController object \"\"\" if command is None : command = DEFAULT_GDB_LAUNCH_COMMAND if not any ([( \"--interpreter=mi\" in c ) for c in command ]): logger . warning ( \"Adding `--interpreter=mi3` (or similar) is recommended to get structured output. \" + \"See https://sourceware.org/gdb/onlinedocs/gdb/Mode-Options.html#Mode-Options.\" ) self . abs_gdb_path = None # abs path to gdb executable self . command : List [ str ] = command self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . gdb_process : Optional [ subprocess . Popen ] = None self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) gdb_path = command [ 0 ] if not gdb_path : raise ValueError ( \"a valid path to gdb must be specified\" ) else : abs_gdb_path = shutil . which ( gdb_path ) if abs_gdb_path is None : raise ValueError ( 'gdb executable could not be resolved from \" %s \"' % gdb_path ) else : self . abs_gdb_path = abs_gdb_path self . spawn_new_gdb_subprocess () def spawn_new_gdb_subprocess ( self ) -> int : \"\"\"Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id \"\"\" if self . gdb_process : logger . debug ( \"Killing current gdb subprocess (pid %d )\" % self . gdb_process . pid ) self . exit () logger . debug ( f 'Launching gdb: { \" \" . join ( self . command ) } ' ) # Use pipes to the standard streams self . gdb_process = subprocess . Popen ( self . command , shell = False , stdout = subprocess . PIPE , stdin = subprocess . PIPE , stderr = subprocess . PIPE , bufsize = 0 , ) assert self . gdb_process . stdin is not None assert self . gdb_process . stdout is not None self . io_manager = IoManager ( self . gdb_process . stdin , self . gdb_process . stdout , self . gdb_process . stderr , self . time_to_check_for_additional_output_sec , ) return self . gdb_process . pid def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , ) -> List [ Dict ]: \"\"\"Get gdb response. See IoManager.get_gdb_response() for details\"\"\" return self . io_manager . get_gdb_response ( timeout_sec , raise_error_on_timeout , return_on_result ) def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , read_response : bool = True , ) -> List [ Dict ]: \"\"\"Write command to gdb. See IoManager.write() for details\"\"\" return self . io_manager . write ( mi_cmd_to_write , timeout_sec , raise_error_on_timeout , return_on_result , read_response , ) def exit ( self ) -> None : \"\"\"Terminate gdb process\"\"\" if self . gdb_process : self . gdb_process . terminate () self . gdb_process . wait () self . gdb_process . communicate () self . gdb_process = None return None","title":"GdbController"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.__init__","text":"Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Parameters: Name Type Description Default command Optional [ List [ str ]] Command to run in shell to spawn new gdb subprocess None time_to_check_for_additional_output_sec float When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC Returns: Type Description None New GdbController object Source code in pygdbmi/gdbcontroller.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def __init__ ( self , command : Optional [ List [ str ]] = None , time_to_check_for_additional_output_sec : float = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ) -> None : \"\"\" Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Args: command: Command to run in shell to spawn new gdb subprocess time_to_check_for_additional_output_sec: When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. Returns: New GdbController object \"\"\" if command is None : command = DEFAULT_GDB_LAUNCH_COMMAND if not any ([( \"--interpreter=mi\" in c ) for c in command ]): logger . warning ( \"Adding `--interpreter=mi3` (or similar) is recommended to get structured output. \" + \"See https://sourceware.org/gdb/onlinedocs/gdb/Mode-Options.html#Mode-Options.\" ) self . abs_gdb_path = None # abs path to gdb executable self . command : List [ str ] = command self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . gdb_process : Optional [ subprocess . Popen ] = None self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) gdb_path = command [ 0 ] if not gdb_path : raise ValueError ( \"a valid path to gdb must be specified\" ) else : abs_gdb_path = shutil . which ( gdb_path ) if abs_gdb_path is None : raise ValueError ( 'gdb executable could not be resolved from \" %s \"' % gdb_path ) else : self . abs_gdb_path = abs_gdb_path self . spawn_new_gdb_subprocess ()","title":"__init__()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.exit","text":"Terminate gdb process Source code in pygdbmi/gdbcontroller.py 137 138 139 140 141 142 143 144 def exit ( self ) -> None : \"\"\"Terminate gdb process\"\"\" if self . gdb_process : self . gdb_process . terminate () self . gdb_process . wait () self . gdb_process . communicate () self . gdb_process = None return None","title":"exit()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.get_gdb_response","text":"Get gdb response. See IoManager.get_gdb_response() for details Source code in pygdbmi/gdbcontroller.py 109 110 111 112 113 114 115 116 117 118 def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , ) -> List [ Dict ]: \"\"\"Get gdb response. See IoManager.get_gdb_response() for details\"\"\" return self . io_manager . get_gdb_response ( timeout_sec , raise_error_on_timeout , return_on_result )","title":"get_gdb_response()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.spawn_new_gdb_subprocess","text":"Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id Source code in pygdbmi/gdbcontroller.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def spawn_new_gdb_subprocess ( self ) -> int : \"\"\"Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id \"\"\" if self . gdb_process : logger . debug ( \"Killing current gdb subprocess (pid %d )\" % self . gdb_process . pid ) self . exit () logger . debug ( f 'Launching gdb: { \" \" . join ( self . command ) } ' ) # Use pipes to the standard streams self . gdb_process = subprocess . Popen ( self . command , shell = False , stdout = subprocess . PIPE , stdin = subprocess . PIPE , stderr = subprocess . PIPE , bufsize = 0 , ) assert self . gdb_process . stdin is not None assert self . gdb_process . stdout is not None self . io_manager = IoManager ( self . gdb_process . stdin , self . gdb_process . stdout , self . gdb_process . stderr , self . time_to_check_for_additional_output_sec , ) return self . gdb_process . pid","title":"spawn_new_gdb_subprocess()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.write","text":"Write command to gdb. See IoManager.write() for details Source code in pygdbmi/gdbcontroller.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , read_response : bool = True , ) -> List [ Dict ]: \"\"\"Write command to gdb. See IoManager.write() for details\"\"\" return self . io_manager . write ( mi_cmd_to_write , timeout_sec , raise_error_on_timeout , return_on_result , read_response , )","title":"write()"},{"location":"api/gdbmiparser/","text":"Python parser for gdb's machine interface interpreter. Parses string output from gdb with the --interpreter=mi2 flag into structured objects. See more at https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI.html#GDB_002fMI parse_response ( gdb_mi_text ) Parse gdb mi text and turn it into a dictionary. See https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Stream-Records.html#GDB_002fMI-Stream-Records for details on types of gdb mi output. Parameters: Name Type Description Default gdb_mi_text str String output from gdb required Returns: Type Description Dict dictionary with keys \"type\", \"message\", \"payload\", \"token\" Source code in pygdbmi/gdbmiparser.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def parse_response ( gdb_mi_text : str ) -> Dict : \"\"\"Parse gdb mi text and turn it into a dictionary. See https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Stream-Records.html#GDB_002fMI-Stream-Records for details on types of gdb mi output. Args: gdb_mi_text: String output from gdb Returns: dictionary with keys \"type\", \"message\", \"payload\", \"token\" \"\"\" stream = StringStream ( gdb_mi_text , debug = _DEBUG ) for pattern , parser in _GDB_MI_PATTERNS_AND_PARSERS : match = pattern . match ( gdb_mi_text ) if match is not None : return parser ( match , stream ) # This was not gdb mi output, so it must have just been printed by # the inferior program that's being debugged return { \"type\" : \"output\" , \"message\" : None , \"payload\" : gdb_mi_text , } response_is_finished ( gdb_mi_text ) Return true if the gdb mi response is ending Parameters: Name Type Description Default gdb_mi_text str String output from gdb required Returns: Type Description bool True if gdb response is finished Source code in pygdbmi/gdbmiparser.py 77 78 79 80 81 82 83 84 85 86 def response_is_finished ( gdb_mi_text : str ) -> bool : \"\"\"Return true if the gdb mi response is ending Args: gdb_mi_text: String output from gdb Returns: True if gdb response is finished \"\"\" return _GDB_MI_RESPONSE_FINISHED_RE . match ( gdb_mi_text ) is not None","title":"gdbmiparser"},{"location":"api/gdbmiparser/#pygdbmi.gdbmiparser.parse_response","text":"Parse gdb mi text and turn it into a dictionary. See https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Stream-Records.html#GDB_002fMI-Stream-Records for details on types of gdb mi output. Parameters: Name Type Description Default gdb_mi_text str String output from gdb required Returns: Type Description Dict dictionary with keys \"type\", \"message\", \"payload\", \"token\" Source code in pygdbmi/gdbmiparser.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def parse_response ( gdb_mi_text : str ) -> Dict : \"\"\"Parse gdb mi text and turn it into a dictionary. See https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Stream-Records.html#GDB_002fMI-Stream-Records for details on types of gdb mi output. Args: gdb_mi_text: String output from gdb Returns: dictionary with keys \"type\", \"message\", \"payload\", \"token\" \"\"\" stream = StringStream ( gdb_mi_text , debug = _DEBUG ) for pattern , parser in _GDB_MI_PATTERNS_AND_PARSERS : match = pattern . match ( gdb_mi_text ) if match is not None : return parser ( match , stream ) # This was not gdb mi output, so it must have just been printed by # the inferior program that's being debugged return { \"type\" : \"output\" , \"message\" : None , \"payload\" : gdb_mi_text , }","title":"parse_response()"},{"location":"api/gdbmiparser/#pygdbmi.gdbmiparser.response_is_finished","text":"Return true if the gdb mi response is ending Parameters: Name Type Description Default gdb_mi_text str String output from gdb required Returns: Type Description bool True if gdb response is finished Source code in pygdbmi/gdbmiparser.py 77 78 79 80 81 82 83 84 85 86 def response_is_finished ( gdb_mi_text : str ) -> bool : \"\"\"Return true if the gdb mi response is ending Args: gdb_mi_text: String output from gdb Returns: True if gdb response is finished \"\"\" return _GDB_MI_RESPONSE_FINISHED_RE . match ( gdb_mi_text ) is not None","title":"response_is_finished()"},{"location":"api/iomanager/","text":"This module defines the IoManager class which manages I/O for file objects connected to an existing gdb process or pty. IoManager Source code in pygdbmi/IoManager.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 class IoManager : def __init__ ( self , stdin : IO [ bytes ], stdout : IO [ bytes ], stderr : Optional [ IO [ bytes ]], time_to_check_for_additional_output_sec : float = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ) -> None : \"\"\" Manage I/O for file objects created before calling this class This can be useful if the gdb process is managed elsewhere, or if a pty is used. \"\"\" self . stdin = stdin self . stdout = stdout self . stderr = stderr self . stdin_fileno = self . stdin . fileno () self . stdout_fileno = self . stdout . fileno () self . stderr_fileno = self . stderr . fileno () if self . stderr else - 1 self . read_list : List [ int ] = [] if self . stdout : self . read_list . append ( self . stdout_fileno ) self . write_list = [ self . stdin_fileno ] self . _incomplete_output : Dict [ str , Any ] = { \"stdout\" : None , \"stderr\" : None } self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) _make_non_blocking ( self . stdout ) if self . stderr : _make_non_blocking ( self . stderr ) def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , ) -> List [ Dict ]: \"\"\"Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Args: timeout_sec: Maximum time to wait for reponse. Must be >= 0. Will return after raise_error_on_timeout: Whether an exception should be raised if no response was found after timeout_sec return_on_result: Whether to return when a response of type 'result' was received. If return_on_result and raise_error_on_timeout, will raise an exception if no response of type 'result' was received. Returns: List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Raises: GdbTimeoutError: if response is not received within timeout_sec ValueError: if select returned unexpected file number \"\"\" if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 if USING_WINDOWS : retval = self . _get_responses_windows ( timeout_sec , return_on_result ) else : retval = self . _get_responses_unix ( timeout_sec , return_on_result ) if not retval and raise_error_on_timeout : raise GdbTimeoutError ( \"Did not get response from gdb after %s seconds\" % timeout_sec ) if ( return_on_result and raise_error_on_timeout and not any ( response [ \"type\" ] == \"result\" for response in retval ) ): raise GdbTimeoutError ( \"Did not get a 'result' response from gdb after %s seconds\" % timeout_sec ) return retval def _get_responses_windows ( self , timeout_sec : float , return_on_result : bool ) -> List [ Dict ]: \"\"\"Get responses on windows. Assume no support for select and use a while loop.\"\"\" timeout_time_sec = time . time () + timeout_sec responses = [] while True : responses_list = [] try : self . stdout . flush () raw_output = self . stdout . readline () . replace ( b \" \\r \" , b \" \\n \" ) responses_list = self . _get_responses_list ( raw_output , \"stdout\" ) except OSError : pass if self . stderr is not None : try : self . stderr . flush () raw_output = self . stderr . readline () . replace ( b \" \\r \" , b \" \\n \" ) responses_list += self . _get_responses_list ( raw_output , \"stderr\" ) except OSError : pass responses += responses_list if return_on_result and any ( response [ \"type\" ] == \"result\" for response in ( responses_list or []) ): break if timeout_sec == 0 : break elif responses_list and self . _allow_overwrite_timeout_times : timeout_time_sec = min ( time . time () + self . time_to_check_for_additional_output_sec , timeout_time_sec , ) elif time . time () > timeout_time_sec : break return responses def _get_responses_unix ( self , timeout_sec : float , return_on_result : bool ) -> List [ Dict ]: \"\"\"Get responses on unix-like system. Use select to wait for output.\"\"\" timeout_time_sec = time . time () + timeout_sec responses = [] while True : select_timeout = timeout_time_sec - time . time () if select_timeout <= 0 : select_timeout = 0 events , _ , _ = select . select ( self . read_list , [], [], select_timeout ) responses_list = None # to avoid infinite loop if using Python 2 for fileno in events : # new data is ready to read if fileno == self . stdout_fileno : self . stdout . flush () raw_output = self . stdout . read () stream = \"stdout\" elif fileno == self . stderr_fileno : assert self . stderr is not None self . stderr . flush () raw_output = self . stderr . read () stream = \"stderr\" else : raise ValueError ( \"Developer error. Got unexpected file number %d \" % fileno ) responses_list = self . _get_responses_list ( raw_output , stream ) responses += responses_list if return_on_result and any ( response [ \"type\" ] == \"result\" for response in ( responses_list or []) ): break if timeout_sec == 0 : # just exit immediately break elif ( responses_list and self . _allow_overwrite_timeout_times and not return_on_result ): # update timeout time to potentially be closer to now to avoid lengthy wait times when nothing is being output by gdb timeout_time_sec = min ( time . time () + self . time_to_check_for_additional_output_sec , timeout_time_sec , ) elif time . time () > timeout_time_sec : break return responses def _get_responses_list ( self , raw_output : bytes , stream : str ) -> List [ Dict [ Any , Any ]]: \"\"\"Get parsed response list from string output Args: raw_output (unicode): gdb output to parse stream (str): either stdout or stderr \"\"\" responses : List [ Dict [ Any , Any ]] = [] ( _new_output , self . _incomplete_output [ stream ], ) = _buffer_incomplete_responses ( raw_output , self . _incomplete_output . get ( stream ) ) if not _new_output : return responses response_list = list ( filter ( lambda x : x , _new_output . decode ( errors = \"replace\" ) . split ( \" \\n \" )) ) # remove blank lines # parse each response from gdb into a dict, and store in a list for response in response_list : if gdbmiparser . response_is_finished ( response ): pass else : parsed_response = gdbmiparser . parse_response ( response ) parsed_response [ \"stream\" ] = stream logger . debug ( \" %s \" , pformat ( parsed_response )) responses . append ( parsed_response ) return responses def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , read_response : bool = True , ) -> List [ Dict ]: \"\"\"Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Args: mi_cmd_to_write: String to write to gdb. If list, it is joined by newlines. timeout_sec: Maximum number of seconds to wait for response before exiting. Must be >= 0. raise_error_on_timeout: If read_response is True, raise error if no response is received return_on_result: Whether to return when a response of type 'result' was received. If return_on_result and raise_error_on_timeout, will raise an exception if no response of type 'result' was received. read_response: Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. Returns: List of parsed gdb responses if read_response is True, otherwise [] Raises: TypeError: if mi_cmd_to_write is not valid \"\"\" # self.verify_valid_gdb_subprocess() if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 # Ensure proper type of the mi command if isinstance ( mi_cmd_to_write , str ): mi_cmd_to_write_str = mi_cmd_to_write elif isinstance ( mi_cmd_to_write , list ): mi_cmd_to_write_str = \" \\n \" . join ( mi_cmd_to_write ) else : raise TypeError ( \"The gdb mi command must a be str or list. Got \" + str ( type ( mi_cmd_to_write )) ) logger . debug ( \"writing: %s \" , mi_cmd_to_write ) if not mi_cmd_to_write_str . endswith ( \" \\n \" ): mi_cmd_to_write_nl = mi_cmd_to_write_str + \" \\n \" else : mi_cmd_to_write_nl = mi_cmd_to_write_str if USING_WINDOWS : # select not implemented in windows for pipes # assume it's always ready outputready = [ self . stdin_fileno ] else : _ , outputready , _ = select . select ([], self . write_list , [], timeout_sec ) for fileno in outputready : if fileno == self . stdin_fileno : # ready to write self . stdin . write ( mi_cmd_to_write_nl . encode ()) # type: ignore # must flush, otherwise gdb won't realize there is data # to evaluate, and we won't get a response self . stdin . flush () # type: ignore else : logger . error ( \"got unexpected fileno %d \" % fileno ) if read_response is True : return self . get_gdb_response ( timeout_sec = timeout_sec , raise_error_on_timeout = raise_error_on_timeout , return_on_result = return_on_result , ) else : return [] __init__ ( stdin , stdout , stderr , time_to_check_for_additional_output_sec = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC ) Manage I/O for file objects created before calling this class This can be useful if the gdb process is managed elsewhere, or if a pty is used. Source code in pygdbmi/IoManager.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __init__ ( self , stdin : IO [ bytes ], stdout : IO [ bytes ], stderr : Optional [ IO [ bytes ]], time_to_check_for_additional_output_sec : float = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ) -> None : \"\"\" Manage I/O for file objects created before calling this class This can be useful if the gdb process is managed elsewhere, or if a pty is used. \"\"\" self . stdin = stdin self . stdout = stdout self . stderr = stderr self . stdin_fileno = self . stdin . fileno () self . stdout_fileno = self . stdout . fileno () self . stderr_fileno = self . stderr . fileno () if self . stderr else - 1 self . read_list : List [ int ] = [] if self . stdout : self . read_list . append ( self . stdout_fileno ) self . write_list = [ self . stdin_fileno ] self . _incomplete_output : Dict [ str , Any ] = { \"stdout\" : None , \"stderr\" : None } self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) _make_non_blocking ( self . stdout ) if self . stderr : _make_non_blocking ( self . stderr ) get_gdb_response ( timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True , return_on_result = False ) Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Parameters: Name Type Description Default timeout_sec float Maximum time to wait for reponse. Must be >= 0. Will return after DEFAULT_GDB_TIMEOUT_SEC raise_error_on_timeout bool Whether an exception should be raised if no response was found after timeout_sec True return_on_result bool Whether to return when a response of type 'result' was received. If return_on_result and raise_error_on_timeout, will raise an exception if no response of type 'result' was received. False Returns: Type Description List [ Dict ] List of parsed GDB responses, returned from gdbmiparser.parse_response, with the List [ Dict ] additional key 'stream' which is either 'stdout' or 'stderr' Raises: Type Description GdbTimeoutError if response is not received within timeout_sec ValueError if select returned unexpected file number Source code in pygdbmi/IoManager.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , ) -> List [ Dict ]: \"\"\"Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Args: timeout_sec: Maximum time to wait for reponse. Must be >= 0. Will return after raise_error_on_timeout: Whether an exception should be raised if no response was found after timeout_sec return_on_result: Whether to return when a response of type 'result' was received. If return_on_result and raise_error_on_timeout, will raise an exception if no response of type 'result' was received. Returns: List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Raises: GdbTimeoutError: if response is not received within timeout_sec ValueError: if select returned unexpected file number \"\"\" if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 if USING_WINDOWS : retval = self . _get_responses_windows ( timeout_sec , return_on_result ) else : retval = self . _get_responses_unix ( timeout_sec , return_on_result ) if not retval and raise_error_on_timeout : raise GdbTimeoutError ( \"Did not get response from gdb after %s seconds\" % timeout_sec ) if ( return_on_result and raise_error_on_timeout and not any ( response [ \"type\" ] == \"result\" for response in retval ) ): raise GdbTimeoutError ( \"Did not get a 'result' response from gdb after %s seconds\" % timeout_sec ) return retval write ( mi_cmd_to_write , timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True , return_on_result = False , read_response = True ) Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Parameters: Name Type Description Default mi_cmd_to_write Union [ str , List [ str ]] String to write to gdb. If list, it is joined by newlines. required timeout_sec float Maximum number of seconds to wait for response before exiting. Must be >= 0. DEFAULT_GDB_TIMEOUT_SEC raise_error_on_timeout bool If read_response is True, raise error if no response is received True return_on_result bool Whether to return when a response of type 'result' was received. If return_on_result and raise_error_on_timeout, will raise an exception if no response of type 'result' was received. False read_response bool Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. True Returns: Type Description List [ Dict ] List of parsed gdb responses if read_response is True, otherwise [] Raises: Type Description TypeError if mi_cmd_to_write is not valid Source code in pygdbmi/IoManager.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , read_response : bool = True , ) -> List [ Dict ]: \"\"\"Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Args: mi_cmd_to_write: String to write to gdb. If list, it is joined by newlines. timeout_sec: Maximum number of seconds to wait for response before exiting. Must be >= 0. raise_error_on_timeout: If read_response is True, raise error if no response is received return_on_result: Whether to return when a response of type 'result' was received. If return_on_result and raise_error_on_timeout, will raise an exception if no response of type 'result' was received. read_response: Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. Returns: List of parsed gdb responses if read_response is True, otherwise [] Raises: TypeError: if mi_cmd_to_write is not valid \"\"\" # self.verify_valid_gdb_subprocess() if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 # Ensure proper type of the mi command if isinstance ( mi_cmd_to_write , str ): mi_cmd_to_write_str = mi_cmd_to_write elif isinstance ( mi_cmd_to_write , list ): mi_cmd_to_write_str = \" \\n \" . join ( mi_cmd_to_write ) else : raise TypeError ( \"The gdb mi command must a be str or list. Got \" + str ( type ( mi_cmd_to_write )) ) logger . debug ( \"writing: %s \" , mi_cmd_to_write ) if not mi_cmd_to_write_str . endswith ( \" \\n \" ): mi_cmd_to_write_nl = mi_cmd_to_write_str + \" \\n \" else : mi_cmd_to_write_nl = mi_cmd_to_write_str if USING_WINDOWS : # select not implemented in windows for pipes # assume it's always ready outputready = [ self . stdin_fileno ] else : _ , outputready , _ = select . select ([], self . write_list , [], timeout_sec ) for fileno in outputready : if fileno == self . stdin_fileno : # ready to write self . stdin . write ( mi_cmd_to_write_nl . encode ()) # type: ignore # must flush, otherwise gdb won't realize there is data # to evaluate, and we won't get a response self . stdin . flush () # type: ignore else : logger . error ( \"got unexpected fileno %d \" % fileno ) if read_response is True : return self . get_gdb_response ( timeout_sec = timeout_sec , raise_error_on_timeout = raise_error_on_timeout , return_on_result = return_on_result , ) else : return []","title":"iomanager"},{"location":"api/iomanager/#pygdbmi.IoManager.IoManager","text":"Source code in pygdbmi/IoManager.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 class IoManager : def __init__ ( self , stdin : IO [ bytes ], stdout : IO [ bytes ], stderr : Optional [ IO [ bytes ]], time_to_check_for_additional_output_sec : float = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ) -> None : \"\"\" Manage I/O for file objects created before calling this class This can be useful if the gdb process is managed elsewhere, or if a pty is used. \"\"\" self . stdin = stdin self . stdout = stdout self . stderr = stderr self . stdin_fileno = self . stdin . fileno () self . stdout_fileno = self . stdout . fileno () self . stderr_fileno = self . stderr . fileno () if self . stderr else - 1 self . read_list : List [ int ] = [] if self . stdout : self . read_list . append ( self . stdout_fileno ) self . write_list = [ self . stdin_fileno ] self . _incomplete_output : Dict [ str , Any ] = { \"stdout\" : None , \"stderr\" : None } self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) _make_non_blocking ( self . stdout ) if self . stderr : _make_non_blocking ( self . stderr ) def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , ) -> List [ Dict ]: \"\"\"Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Args: timeout_sec: Maximum time to wait for reponse. Must be >= 0. Will return after raise_error_on_timeout: Whether an exception should be raised if no response was found after timeout_sec return_on_result: Whether to return when a response of type 'result' was received. If return_on_result and raise_error_on_timeout, will raise an exception if no response of type 'result' was received. Returns: List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Raises: GdbTimeoutError: if response is not received within timeout_sec ValueError: if select returned unexpected file number \"\"\" if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 if USING_WINDOWS : retval = self . _get_responses_windows ( timeout_sec , return_on_result ) else : retval = self . _get_responses_unix ( timeout_sec , return_on_result ) if not retval and raise_error_on_timeout : raise GdbTimeoutError ( \"Did not get response from gdb after %s seconds\" % timeout_sec ) if ( return_on_result and raise_error_on_timeout and not any ( response [ \"type\" ] == \"result\" for response in retval ) ): raise GdbTimeoutError ( \"Did not get a 'result' response from gdb after %s seconds\" % timeout_sec ) return retval def _get_responses_windows ( self , timeout_sec : float , return_on_result : bool ) -> List [ Dict ]: \"\"\"Get responses on windows. Assume no support for select and use a while loop.\"\"\" timeout_time_sec = time . time () + timeout_sec responses = [] while True : responses_list = [] try : self . stdout . flush () raw_output = self . stdout . readline () . replace ( b \" \\r \" , b \" \\n \" ) responses_list = self . _get_responses_list ( raw_output , \"stdout\" ) except OSError : pass if self . stderr is not None : try : self . stderr . flush () raw_output = self . stderr . readline () . replace ( b \" \\r \" , b \" \\n \" ) responses_list += self . _get_responses_list ( raw_output , \"stderr\" ) except OSError : pass responses += responses_list if return_on_result and any ( response [ \"type\" ] == \"result\" for response in ( responses_list or []) ): break if timeout_sec == 0 : break elif responses_list and self . _allow_overwrite_timeout_times : timeout_time_sec = min ( time . time () + self . time_to_check_for_additional_output_sec , timeout_time_sec , ) elif time . time () > timeout_time_sec : break return responses def _get_responses_unix ( self , timeout_sec : float , return_on_result : bool ) -> List [ Dict ]: \"\"\"Get responses on unix-like system. Use select to wait for output.\"\"\" timeout_time_sec = time . time () + timeout_sec responses = [] while True : select_timeout = timeout_time_sec - time . time () if select_timeout <= 0 : select_timeout = 0 events , _ , _ = select . select ( self . read_list , [], [], select_timeout ) responses_list = None # to avoid infinite loop if using Python 2 for fileno in events : # new data is ready to read if fileno == self . stdout_fileno : self . stdout . flush () raw_output = self . stdout . read () stream = \"stdout\" elif fileno == self . stderr_fileno : assert self . stderr is not None self . stderr . flush () raw_output = self . stderr . read () stream = \"stderr\" else : raise ValueError ( \"Developer error. Got unexpected file number %d \" % fileno ) responses_list = self . _get_responses_list ( raw_output , stream ) responses += responses_list if return_on_result and any ( response [ \"type\" ] == \"result\" for response in ( responses_list or []) ): break if timeout_sec == 0 : # just exit immediately break elif ( responses_list and self . _allow_overwrite_timeout_times and not return_on_result ): # update timeout time to potentially be closer to now to avoid lengthy wait times when nothing is being output by gdb timeout_time_sec = min ( time . time () + self . time_to_check_for_additional_output_sec , timeout_time_sec , ) elif time . time () > timeout_time_sec : break return responses def _get_responses_list ( self , raw_output : bytes , stream : str ) -> List [ Dict [ Any , Any ]]: \"\"\"Get parsed response list from string output Args: raw_output (unicode): gdb output to parse stream (str): either stdout or stderr \"\"\" responses : List [ Dict [ Any , Any ]] = [] ( _new_output , self . _incomplete_output [ stream ], ) = _buffer_incomplete_responses ( raw_output , self . _incomplete_output . get ( stream ) ) if not _new_output : return responses response_list = list ( filter ( lambda x : x , _new_output . decode ( errors = \"replace\" ) . split ( \" \\n \" )) ) # remove blank lines # parse each response from gdb into a dict, and store in a list for response in response_list : if gdbmiparser . response_is_finished ( response ): pass else : parsed_response = gdbmiparser . parse_response ( response ) parsed_response [ \"stream\" ] = stream logger . debug ( \" %s \" , pformat ( parsed_response )) responses . append ( parsed_response ) return responses def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , read_response : bool = True , ) -> List [ Dict ]: \"\"\"Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Args: mi_cmd_to_write: String to write to gdb. If list, it is joined by newlines. timeout_sec: Maximum number of seconds to wait for response before exiting. Must be >= 0. raise_error_on_timeout: If read_response is True, raise error if no response is received return_on_result: Whether to return when a response of type 'result' was received. If return_on_result and raise_error_on_timeout, will raise an exception if no response of type 'result' was received. read_response: Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. Returns: List of parsed gdb responses if read_response is True, otherwise [] Raises: TypeError: if mi_cmd_to_write is not valid \"\"\" # self.verify_valid_gdb_subprocess() if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 # Ensure proper type of the mi command if isinstance ( mi_cmd_to_write , str ): mi_cmd_to_write_str = mi_cmd_to_write elif isinstance ( mi_cmd_to_write , list ): mi_cmd_to_write_str = \" \\n \" . join ( mi_cmd_to_write ) else : raise TypeError ( \"The gdb mi command must a be str or list. Got \" + str ( type ( mi_cmd_to_write )) ) logger . debug ( \"writing: %s \" , mi_cmd_to_write ) if not mi_cmd_to_write_str . endswith ( \" \\n \" ): mi_cmd_to_write_nl = mi_cmd_to_write_str + \" \\n \" else : mi_cmd_to_write_nl = mi_cmd_to_write_str if USING_WINDOWS : # select not implemented in windows for pipes # assume it's always ready outputready = [ self . stdin_fileno ] else : _ , outputready , _ = select . select ([], self . write_list , [], timeout_sec ) for fileno in outputready : if fileno == self . stdin_fileno : # ready to write self . stdin . write ( mi_cmd_to_write_nl . encode ()) # type: ignore # must flush, otherwise gdb won't realize there is data # to evaluate, and we won't get a response self . stdin . flush () # type: ignore else : logger . error ( \"got unexpected fileno %d \" % fileno ) if read_response is True : return self . get_gdb_response ( timeout_sec = timeout_sec , raise_error_on_timeout = raise_error_on_timeout , return_on_result = return_on_result , ) else : return []","title":"IoManager"},{"location":"api/iomanager/#pygdbmi.IoManager.IoManager.__init__","text":"Manage I/O for file objects created before calling this class This can be useful if the gdb process is managed elsewhere, or if a pty is used. Source code in pygdbmi/IoManager.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __init__ ( self , stdin : IO [ bytes ], stdout : IO [ bytes ], stderr : Optional [ IO [ bytes ]], time_to_check_for_additional_output_sec : float = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ) -> None : \"\"\" Manage I/O for file objects created before calling this class This can be useful if the gdb process is managed elsewhere, or if a pty is used. \"\"\" self . stdin = stdin self . stdout = stdout self . stderr = stderr self . stdin_fileno = self . stdin . fileno () self . stdout_fileno = self . stdout . fileno () self . stderr_fileno = self . stderr . fileno () if self . stderr else - 1 self . read_list : List [ int ] = [] if self . stdout : self . read_list . append ( self . stdout_fileno ) self . write_list = [ self . stdin_fileno ] self . _incomplete_output : Dict [ str , Any ] = { \"stdout\" : None , \"stderr\" : None } self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) _make_non_blocking ( self . stdout ) if self . stderr : _make_non_blocking ( self . stderr )","title":"__init__()"},{"location":"api/iomanager/#pygdbmi.IoManager.IoManager.get_gdb_response","text":"Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Parameters: Name Type Description Default timeout_sec float Maximum time to wait for reponse. Must be >= 0. Will return after DEFAULT_GDB_TIMEOUT_SEC raise_error_on_timeout bool Whether an exception should be raised if no response was found after timeout_sec True return_on_result bool Whether to return when a response of type 'result' was received. If return_on_result and raise_error_on_timeout, will raise an exception if no response of type 'result' was received. False Returns: Type Description List [ Dict ] List of parsed GDB responses, returned from gdbmiparser.parse_response, with the List [ Dict ] additional key 'stream' which is either 'stdout' or 'stderr' Raises: Type Description GdbTimeoutError if response is not received within timeout_sec ValueError if select returned unexpected file number Source code in pygdbmi/IoManager.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , ) -> List [ Dict ]: \"\"\"Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Args: timeout_sec: Maximum time to wait for reponse. Must be >= 0. Will return after raise_error_on_timeout: Whether an exception should be raised if no response was found after timeout_sec return_on_result: Whether to return when a response of type 'result' was received. If return_on_result and raise_error_on_timeout, will raise an exception if no response of type 'result' was received. Returns: List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Raises: GdbTimeoutError: if response is not received within timeout_sec ValueError: if select returned unexpected file number \"\"\" if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 if USING_WINDOWS : retval = self . _get_responses_windows ( timeout_sec , return_on_result ) else : retval = self . _get_responses_unix ( timeout_sec , return_on_result ) if not retval and raise_error_on_timeout : raise GdbTimeoutError ( \"Did not get response from gdb after %s seconds\" % timeout_sec ) if ( return_on_result and raise_error_on_timeout and not any ( response [ \"type\" ] == \"result\" for response in retval ) ): raise GdbTimeoutError ( \"Did not get a 'result' response from gdb after %s seconds\" % timeout_sec ) return retval","title":"get_gdb_response()"},{"location":"api/iomanager/#pygdbmi.IoManager.IoManager.write","text":"Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Parameters: Name Type Description Default mi_cmd_to_write Union [ str , List [ str ]] String to write to gdb. If list, it is joined by newlines. required timeout_sec float Maximum number of seconds to wait for response before exiting. Must be >= 0. DEFAULT_GDB_TIMEOUT_SEC raise_error_on_timeout bool If read_response is True, raise error if no response is received True return_on_result bool Whether to return when a response of type 'result' was received. If return_on_result and raise_error_on_timeout, will raise an exception if no response of type 'result' was received. False read_response bool Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. True Returns: Type Description List [ Dict ] List of parsed gdb responses if read_response is True, otherwise [] Raises: Type Description TypeError if mi_cmd_to_write is not valid Source code in pygdbmi/IoManager.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , return_on_result : bool = False , read_response : bool = True , ) -> List [ Dict ]: \"\"\"Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Args: mi_cmd_to_write: String to write to gdb. If list, it is joined by newlines. timeout_sec: Maximum number of seconds to wait for response before exiting. Must be >= 0. raise_error_on_timeout: If read_response is True, raise error if no response is received return_on_result: Whether to return when a response of type 'result' was received. If return_on_result and raise_error_on_timeout, will raise an exception if no response of type 'result' was received. read_response: Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. Returns: List of parsed gdb responses if read_response is True, otherwise [] Raises: TypeError: if mi_cmd_to_write is not valid \"\"\" # self.verify_valid_gdb_subprocess() if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 # Ensure proper type of the mi command if isinstance ( mi_cmd_to_write , str ): mi_cmd_to_write_str = mi_cmd_to_write elif isinstance ( mi_cmd_to_write , list ): mi_cmd_to_write_str = \" \\n \" . join ( mi_cmd_to_write ) else : raise TypeError ( \"The gdb mi command must a be str or list. Got \" + str ( type ( mi_cmd_to_write )) ) logger . debug ( \"writing: %s \" , mi_cmd_to_write ) if not mi_cmd_to_write_str . endswith ( \" \\n \" ): mi_cmd_to_write_nl = mi_cmd_to_write_str + \" \\n \" else : mi_cmd_to_write_nl = mi_cmd_to_write_str if USING_WINDOWS : # select not implemented in windows for pipes # assume it's always ready outputready = [ self . stdin_fileno ] else : _ , outputready , _ = select . select ([], self . write_list , [], timeout_sec ) for fileno in outputready : if fileno == self . stdin_fileno : # ready to write self . stdin . write ( mi_cmd_to_write_nl . encode ()) # type: ignore # must flush, otherwise gdb won't realize there is data # to evaluate, and we won't get a response self . stdin . flush () # type: ignore else : logger . error ( \"got unexpected fileno %d \" % fileno ) if read_response is True : return self . get_gdb_response ( timeout_sec = timeout_sec , raise_error_on_timeout = raise_error_on_timeout , return_on_result = return_on_result , ) else : return []","title":"write()"}]}